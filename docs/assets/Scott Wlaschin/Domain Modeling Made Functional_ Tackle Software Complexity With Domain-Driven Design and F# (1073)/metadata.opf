<?xml version='1.0' encoding='utf-8'?>
<package xmlns="http://www.idpf.org/2007/opf" unique-identifier="uuid_id" version="2.0">
    <metadata xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:opf="http://www.idpf.org/2007/opf">
        <dc:identifier opf:scheme="calibre" id="calibre_id">1073</dc:identifier>
        <dc:identifier opf:scheme="uuid" id="uuid_id">d828bc8c-09af-4c39-960c-827426f47800</dc:identifier>
        <dc:title>Domain Modeling Made Functional: Tackle Software Complexity With Domain-Driven Design and F#</dc:title>
        <dc:creator opf:file-as="Wlaschin, Scott" opf:role="aut">Scott Wlaschin</dc:creator>
        <dc:contributor opf:file-as="calibre" opf:role="bkp">calibre (5.31.1) [https://calibre-ebook.com]</dc:contributor>
        <dc:date>2018-02-04T11:27:15+00:00</dc:date>
        <dc:description>You want increased customer satisfaction, faster development cycles, and less wasted work. Domain-driven design (DDD) combined with functional programming is the innovative combo that will get you there. In this pragmatic, down-to-earth guide, you'll see how applying the core principles of functional programming can result in software designs that model real-world requirements both elegantly and concisely - often more so than an object-oriented approach. Practical examples in the open-source F# functional language, and examples from familiar business domains, show you how to apply these techniques to build software that is business-focused, flexible, and high quality. Domain-driven design is a well-established approach to designing software that ensures that domain experts and developers work together effectively to create high-quality software. This book is the first to combine DDD with techniques from statically typed functional programming. This book is perfect for newcomers to DDD or functional programming - all the techniques you need will be introduced and explained. Model a complex domain accurately using the F# type system, creating compilable code that is also readable documentation---ensuring that the code and design never get out of sync. Encode business rules in the design so that you have "compile-time unit tests," and eliminate many potential bugs by making illegal states unrepresentable. Assemble a series of small, testable functions into a complete use case, and compose these individual scenarios into a large-scale design. Discover why the combination of functional programming and DDD leads naturally to service-oriented and hexagonal architectures. Finally, create a functional domain model that works with traditional databases, NoSQL, and event stores, and safely expose your domain via a website or API. Solve real problems by focusing on real-world requirements for your software. What You Need:  The code in this book is designed to be run interactively on Windows, Mac and Linux.You will need a recent version of F# (4.0 or greater), and the appropriate .NET runtime for your platform.Full installation instructions for all platforms at fsharp.org.</dc:description>
        <dc:publisher>Pragmatic Bookshelf</dc:publisher>
        <dc:identifier opf:scheme="GOOGLE">SMNLtAEACAAJ</dc:identifier>
        <dc:identifier opf:scheme="ISBN">9781680502541</dc:identifier>
        <dc:language>eng</dc:language>
        <dc:subject>Computers</dc:subject>
        <dc:subject>Systems Architecture</dc:subject>
        <dc:subject>General</dc:subject>
        <dc:subject>Software Development &amp; Engineering</dc:subject>
        <dc:subject>Tools</dc:subject>
        <dc:subject>Data Modeling &amp; Design</dc:subject>
        <meta name="calibre:author_link_map" content="{&quot;Scott Wlaschin&quot;: &quot;&quot;}"/>
        <meta name="calibre:timestamp" content="2020-11-09T19:36:24+00:00"/>
        <meta name="calibre:title_sort" content="Domain Modeling Made Functional: Tackle Software Complexity With Domain-Driven Design and F#"/>
    </metadata>
    <guide>
        <reference type="cover" title="Cover" href="cover.jpg"/>
    </guide>
</package>
